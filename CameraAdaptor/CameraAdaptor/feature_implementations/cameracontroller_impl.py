# Generated by sila2.code_generator; sila2.__version__: 0.12.2
from __future__ import annotations

from typing import TYPE_CHECKING
from DataService.DataService import Client as DataClient
import json
import cv2 as cv
import math
import numpy as np
import os
import datetime

from sila2.server import MetadataDict

from ..generated.cameracontroller import CameraControllerBase, CaptureImage_Responses, StoreImage_Responses

if TYPE_CHECKING:
    from ..server import Server

IMAGE_HEIGHT = 550
IMAGE_WIDTH = 550

class CameraControllerImpl(CameraControllerBase):
    def __init__(self, parent_server: Server) -> None:
        self.dataService = DataClient(address="127.0.0.1",  port=50052, insecure=True)
        super().__init__(parent_server=parent_server)

    def _SurfaceTensionFromSDS(self, concentrationSDS):
        if concentrationSDS < 8.212:
            return -3.8071 * concentrationSDS + 68.652
        else:
            return -0.2893 * concentrationSDS + 39.898

    #TODO use polynomial formula once i figure out how to work with Excel
    def _ScalingFactorFromSurfaceTension(self, surfaceTension):
        return -0.0043 * surfaceTension + 1.3018

    def _GenerateImage(self, scalingFactor):
        pipette = cv.imread(os.path.abspath("CameraAdaptor/CameraAdaptor/feature_implementations/pipette.jpg"))
        drop = cv.imread(os.path.abspath("CameraAdaptor/CameraAdaptor/feature_implementations/drop.jpg"))
        background = np.full((IMAGE_HEIGHT, IMAGE_WIDTH, 3), 255, dtype = np.uint8) 

        pipette_y_offset = 0
        pipette_x_offset = math.floor((IMAGE_WIDTH / 2) - (pipette.shape[1] / 2))
        drop_y_offset = pipette.shape[0]
        drop_x_offset = math.floor((IMAGE_WIDTH / 2) - (drop.shape[1] / 2)) + 10

        background[pipette_y_offset:pipette_y_offset + pipette.shape[0], pipette_x_offset:pipette_x_offset + pipette.shape[1]] = pipette
        
        new_height = math.floor(drop.shape[0] * scalingFactor)
        resized_drop = cv.resize(drop, (drop.shape[1], new_height), cv.INTER_LINEAR)
        background[drop_y_offset:drop_y_offset + new_height, drop_x_offset:drop_x_offset + drop.shape[1]] = resized_drop
        return background
    
    def _add_random_noise(self, image, intensity=30):
        noisy_image = image.copy()
        noise = np.random.randint(-intensity, intensity + 1, noisy_image.shape)
        noisy_image = np.clip(noisy_image + noise, 0, 255).astype(np.uint8)
        return noisy_image

    def CaptureImage(self, ExperimentPlanPath: str, *, metadata: MetadataDict) -> CaptureImage_Responses:
        experimentPlanItem = self.dataService.DataItemProvider.GetDataItem(ItemPath=ExperimentPlanPath)
        experimentPlan = json.loads(experimentPlanItem.DataItemContent.decode('utf-8'))
        concentrationSDS = experimentPlan["concentrationSDS"]["concentration"]

        surfaceTension = self._SurfaceTensionFromSDS(concentrationSDS=concentrationSDS)
        scalingFactor = self._ScalingFactorFromSurfaceTension(surfaceTension=surfaceTension)

        dropImage = self._GenerateImage(scalingFactor=scalingFactor)
        self.capture = self._add_random_noise(image=dropImage)

        self.captureTime = datetime.datetime.now().timestamp()
        return CaptureImage_Responses()

    def StoreImage(self, ItemPath: str, *, metadata: MetadataDict) -> StoreImage_Responses:
        self.dataService.DataItemProvider.CreateDataItem(
            ItemPath=ItemPath,
            Content=cv.imencode('.jpg', self.capture)[1].tostring(),
            ItemProperties=[
                tuple(["creationTime", f"{self.captureTime}"]),
                tuple(["height", f"{IMAGE_HEIGHT}"]),
                tuple(["width", f"{IMAGE_WIDTH}"]),
            ]
        )
        return StoreImage_Responses()
